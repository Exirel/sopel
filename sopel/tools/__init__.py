"""Useful miscellaneous tools and shortcuts for Sopel plugins

.. versionadded:: 3.0
"""

# tools.py - Sopel misc tools
# Copyright 2008, Sean B. Palmer, inamidst.com
# Copyright Â© 2012, Elad Alfassa <elad@fedoraproject.org>
# Copyright 2012, Elsie Powell, embolalia.com
# Licensed under the Eiffel Forum License 2.

# https://sopel.chat

from __future__ import annotations

import logging
import re

# Don't delete `deprecated` import - maintains backward compatibility with pre-8.0 API
from sopel.lifecycle import deprecated  # NOQA

from . import time, web  # NOQA
from ._events import events  # NOQA

# shortcuts & backward compatibility with pre-8.0
from .identifiers import Identifier  # NOQA
from .memories import (  # NOQA
    SopelIdentifierMemory,
    SopelMemory,
    SopelMemoryWithDefault,
)


def get_sendable_message(text, max_length=400):
    """Get a sendable ``text`` message, with its excess when needed.

    :param str txt: text to send (expects Unicode-encoded string)
    :param int max_length: maximum length of the message to be sendable
    :return: a tuple of two values, the sendable text and its excess text
    :rtype: (str, str)

    We're arbitrarily saying that the (default) max is 400 bytes of text
    when messages will be split, but callers can specify a different value
    (e.g. to account precisely for the bot's hostmask).

    The ``max_length`` is the max length of text in **bytes**, but we take
    care of multibyte UTF-8 characters by working on the Unicode string,
    then making sure the bytes version is smaller than the max length.

    .. note::

        In most cases, letting the bot gracefully handle message truncation
        using optional arguments to :meth:`bot.say() <.bot.Sopel.say>` is
        preferable. However, this function is part of the public API to provide
        for more advanced use-cases.

        See also the :meth:`bot.safe_text_length() <.bot.Sopel.safe_text_length>`
        method, whose return value can be passed as this function's
        ``max_length`` argument.

    .. versionadded:: 6.6.2
    """
    unicode_max_length = max_length
    excess = ''

    while len(text.encode('utf-8')) > max_length:
        last_space = text.rfind(' ', 0, unicode_max_length)
        if last_space == -1:
            # No last space, just split where it is possible
            excess = text[unicode_max_length:] + excess
            text = text[:unicode_max_length]
            # Decrease max length for the unicode string
            unicode_max_length = unicode_max_length - 1
        else:
            # Split at the last best space found
            excess = text[last_space:] + excess
            text = text[:last_space]

    return text, excess.lstrip()


def get_hostmask_regex(mask):
    """Get a compiled regex pattern for an IRC hostmask

    :param str mask: the hostmask that the pattern should match
    :return: a compiled regex pattern matching the given ``mask``
    :rtype: :ref:`re.Pattern <python:re-objects>`

    .. versionadded:: 4.4
    """
    mask = re.escape(mask)
    mask = mask.replace(r'\*', '.*')
    return re.compile(mask + '$', re.I)


def get_logger(plugin_name):
    """Return a logger for a plugin.

    :param str plugin_name: name of the plugin
    :return: the logger for the given plugin

    This::

        from sopel import tools
        LOGGER = tools.get_logger('my_custom_plugin')

    is equivalent to this::

        import logging
        LOGGER = logging.getLogger('sopel.thirdparty.my_custom_plugin')

    Internally, Sopel configures logging for the ``sopel`` namespace, so
    external plugins can't benefit from it with ``logging.getLogger(__name__)``
    as they won't be in the same namespace. This function uses the
    ``plugin_name`` with a prefix inside this namespace.

    .. versionadded:: 7.0
    .. versionchanged:: 8.1
        Moved plugin loggers from ``sopel.externals`` namespace to
        ``sopel.thirdparty``, aligning with :func:`sopel.lifecycle.deprecated`.
    """
    return logging.getLogger('sopel.thirdparty.%s' % plugin_name)


def chain_loaders(*lazy_loaders):
    """Chain lazy loaders into one.

    :param lazy_loaders: one or more lazy loader functions
    :type lazy_loaders: :term:`function`
    :return: a lazy loader that combines all of the given ones
    :rtype: :term:`function`

    This function takes any number of lazy loaders as arguments and merges them
    together into one. It's primarily a helper for lazy rule decorators such as
    :func:`sopel.plugin.url_lazy`.

    .. versionadded:: 7.1

    .. important::

        This function doesn't check the uniqueness of regexes generated by
        all the loaders.

    """
    def chained_loader(settings):
        return [
            regex
            for lazy_loader in lazy_loaders
            for regex in lazy_loader(settings)
        ]
    return chained_loader
